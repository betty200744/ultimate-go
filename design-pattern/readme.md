
* 设计模式存在的价值是帮助程序员沟通，现在一般不用设计模式，现在都用第三方依赖， 语法糖


### Creational

创建型模式
创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。

创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。


* 简单工厂模式（Simple Factory）
* 工厂方法模式（Factory Method）
* 抽象工厂模式（Abstract Factory）
* 建造者模式（Builder）
* 原型模式（Prototype）
* 单例模式（Singleton）

### structual

These concern class and object composition. They use inheritance to compose interfaces and define ways to compose objects to obtain new functionality.

结构型模式
结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。

结构型模式可以分为类结构型模式和对象结构型模式：

类结构型模式关心类的组合，由多个类可以组合成一个更大的
系统，在类结构型模式中一般只存在继承关系和实现关系。 - 对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。


* 适配器模式(Adapter)
* 桥接模式(Bridge)
* 组合模式(Composite)
* 装饰模式(Decorator)
* 外观模式(Facade)
* 享元模式(Flyweight)
* 代理模式(Proxy)

### behavioral


行为型模式
行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。

行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。

通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

行为型模式分为类行为型模式和对象行为型模式两种：

类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。
对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

* 职责链模式(Chain of Responsibility) , 即middleware中间件的感觉
* 命令模式(Command)
* 解释器模式(Interpreter)
* 迭代器模式(Iterator)
* 中介者模式(Mediator)
* 备忘录模式(Memento)
* 观察者模式(Observer)
* 状态模式(State)
* 策略模式(Strategy), 登录用不同的账号登录， 即策略， 付款用不同的方式付款，也是策略， kafka消费数据用不同的策略
* 模板方法模式(Template Method)
* 访问者模式(Visitor)